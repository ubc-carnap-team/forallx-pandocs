A formal semantics for QL {#ch.QL.models}
=========================

In this chapter, we describe a *formal semantics* for QL. This
corresponds to the discussion of interpretations and truth in SL given
in Chapter [\[ch.SLmodels\]](#ch.SLmodels){reference-type="ref"
reference="ch.SLmodels"}. Like truth in SL, truth in QL is defined
relative to a particular interpretation; entailment is a matter of truth
in all interpretations. In SL, models corresponded to assignments of
truth values to atomic sentences. For example, here is an SL model:

$$\script{I} =
\left\{
    \begin{array}{ll}
    P = 0\\
    Q = 1\\
    R = 0
    \end{array}
\right.$$

Interpretation settles the truth value of any SL sentence one can
construct from $P$, $Q$, and $R$. Because QL involves richer notions and
a more complex vocabulary than SL, it requires correspondingly richer
models and interpretations.

Interpretations in QL
---------------------

What is an interpretation in QL? Like a symbolization key for QL, an
interpretation requires a universe of discourse, a schematic meaning for
each of the predicates, and an object that is picked out by each
constant. For example:

Marvel characters

$x$ is a hero.

$x$ has spider powers.

Miles Morales

Peter Parker

The Red Skull

Susan Storm

Ultimate Spider-Man

This interpretation is given in terms of English descriptions. To apply
it, you need to know some details about the characters in question. For
example, $Sm$ is true on this interpretation, because Miles Morales does
have spider powers. But the interpretation itself doesn't tell us that
--- to get that information from this way of setting out the
interpretation, you need to know some details about what happens in the
story. You need to know, for example, that Miles Morales, like his more
famous mentor Peter Parker, also has spider powers. If you do know a bit
about Marvel comics, you may know that Miles Morales is actually the
Ultimate Spider-Man. So $u$ and $m$ in this interpretation are two
different names for the same member of the UD. There is no rule against
having multiple names for the same member. (We'll discuss this issue in
much more detail in Chapter
[\[ch.identity\]](#ch.identity){reference-type="ref"
reference="ch.identity"}.)

We want our QL models to encode this kind of information too. Like a
good SL model, a QL model shouldn't require prior knowledge of comic
books. One way we could try to do this would be to just give a truth
value assignment, as we did for SL. The truth value assignment would
assign 0 or 1 to each atomic wff: $Sm=1$, $Sp=1$, $Sr=0$, and so on. If
we were to do that, however, we might just as well translate the
sentences from QL to SL by replacing $Sp$ and $Sm$ with sentence
letters. We could then rely on the definition of truth for SL, but at
the cost of ignoring all the logical structure of predicates and terms.
In writing a symbolization key for QL, we do not give separate
definitions for $Sp$ and $Sm$. Instead, we give meanings to the
components $S$, $p$, and $m$. This is essential because we want to be
able to reflect the logical relationships between e.g. $Sp$ and
$\exists x Sx$.

Our interpretations should include explanations for predicates and
names, not just for sentences. We cannot use a truth value assignment
for this, because a predicate by itself is neither true nor false. In
the interpretation given above, $H$ is true *of* Peter Parker (i.e.,
$Hp$ is true), but it makes no sense at all to ask whether $H$ on its
own is true. It would be like asking whether the English language
fragment '$\ldots$is a hero' is true.

What does an interpretation do for a predicate, if it does not make it
true or false? An interpretation helps to pick out the objects to which
the predicate applies. Interpreting $Hx$ to mean '$x$ is a hero' picks
out some characters as the things that are $H$s. Formally, this is a set
of members of the UD to which the predicate applies; this set is called
the of the predicate.

Some predicates have indefinitely large extensions. It would be
impractical to try and write down all of the Marvel characters
individually, so instead we use an English language expression to
interpret the predicate. This is somewhat imprecise, because the
interpretation alone does not tell you which members of the UD are in
the extension of the predicate. In order to figure out whether a
particular member of the UD is in the extension of the predicate (to
figure out whether the Red Skull is a hero, for instance), you need to
know about comic books. (As you might guess from his name, he's not.) In
general, the extension of a predicate is the result of an interpretation
*along with* some facts.

Sometimes it is possible to list all of the things that are in the
extension of a predicate. Instead of writing a schematic English
sentence, we can write down the extension as a set of things. Suppose we
wanted to add a one-place predicate $F$ to the key above, meaning '$x$
is a founding member of the Fantastic Four', so we write the extension
as a set of characters:

& {Reed Richards, Susan Storm, Johnny Storm, Ben Grimm}

You do not need to know anything about comic books to be able to
determine that, on this interpretation, $Fs$ is true: Susan Storm, whose
name is given as $s$, is just specified to be one of the things that is
$F$. Similarly, $\exists x Fx$ is obviously true on this interpretation:
There is at least one member of the UD that is an $F$ --- in fact, there
are four of them.

What about the sentence $\forall x Fx$? The sentence is false, because
it is not true that all members of the UD are $F$. It requires the
barest minimum of knowledge about comic books to know that there are
other characters besides just these four. Although we specified the
extension of $F$ in a formally precise way, we still specified the UD
with an English language description. Formally speaking, a UD is just a
set of members.

The formal significance of a predicate is determined by its extension,
but what should we say about constants like $m$ and $s$? The meaning of
a constant determines which member of the UD is picked out by the
constant. The individual that the constant picks out is called the of
the constant. Both $m$ and $u$ have the same referent, since they both
refer to the same comic book character. You can think of a constant
letter as a name and the referent as the thing named. In English, we can
use the different names 'Miles' and 'Ultimate Spider-Man' to refer to
the same comic book character. In this interpretation, we also use the
different constants '$m$' and '$u$' to refer to the same member of the
UD.

Sets
----

We use curly brackets '{' and '}' to denote sets. The members of the set
can be listed in any order, separated by commas. This means that {foo,
bar} and {bar, foo} are the same set.

It is possible to have a set with no members in it. This is called the .
The empty set is sometimes written as {}, but usually it is written as
the single symbol $\emptyset$.

Models
------

As we have seen, an interpretation in QL is only formally significant
insofar as it determines a UD, an extension for each predicate, and a
referent for each constant. We call this formal structure a for QL.

To see how this works, consider this symbolization key:

The first ten natural numbers

$x$ is prime.

4

Given some basic mathematical knowledge, it is obvious that $Pn_{4}$ is
false. Let's consider the model this interpretation suggests, to show
why it makes this wff false. Instead of just giving a description in the
UD, we can list the members as a set. We also define the extension of
the predicate $P$, and the referent of the constant $n_{4}$:

UD & $\{1, 2, 3, 4, 5, 6, 7, 8, 9, 10\}$\
& {2, 3, 5, 7}\
& 4

This is not a full model for this interpretation, but it is a detailed
enough partial model to show that $Pn_{4}$ is false. You do not need to
know anything about mathematics to see that this sentence is false in
this model. The UD member named by $n_{4}$ is not in the extension of
$P$. In this way, the model captures all of the formal significance of
the interpretation.

Suppose we enrich this interpretation with more predicates:
[\[10UD\]]{#10UD label="10UD"}

UD: The first ten natural numbers

Ex: $x$ is even.

Nx: $x$ is negative.

Lxy: $x$ is less than $y$.

Txyz: $x$ times $y$ equals $z$.

What do we need to add to the model for our new predicates?

The extension of $E$ is the subset $\{2, 4, 6, 8, 10\}$. There are no
negative numbers in the UD, so $N$ has an empty extension; i.e.
$\extension{N}=\emptyset$.

Sometimes it will be convenient to represent extensions graphically,
similar to the way we did with truth tables. We can represent the
extensions just described for $P$, $E$, and $N$ thus:

           $P$   $E$   $N$
  -------- ----- ----- -----
  **1**    0     0     0
  **2**    1     1     0
  **3**    1     0     0
  **4**    0     1     0
  **5**    1     0     0
  **6**    0     1     0
  **7**    1     0     0
  **8**    0     1     0
  **9**    0     0     0
  **10**   0     1     0

The members of the UD are listed as rows; the predicates are given as
columns. The 0s and 1s indicate whether each member satisfies each
predicate. Notice that the same information is conveyed in this chart as
in the three sets of ordered pairs described above. Either is an
acceptable way of indicating the extension of the predicates.

The extension of a two-place predicate like $L$ is more complicated. No
individual number falls under the extension of this predicate; it is
about the relation between members. Note also that sets of pairs numbers
aren't suitable for the extension of $L$ either, because 1 is less than
8, but 8 is not less than 1. And the set {1,8} is the very same set as
the set {8,1}. The solution is to have the extension of $L$ consist in a
set of of numbers. An ordered pair is like a set with two members,
except that the order *does* matter. We write ordered pairs with angle
brackets '$\openntuple$' and '$\closentuple$'. The ordered pair is
different than the ordered pair . The extension of $L$ is a collection
of ordered pairs, all of the pairs of numbers in the UD such that the
first number is less than the second. Writing this out completely:

$\extension{L}=$ {, , , , , , , , , , , , , , , , , , , , , , , , , , ,
, , , , , , , , , , , , , , , , }

Formally, the extension of a two-place predicate is a set of ordered
pairs. Sometimes we will find it easier to represent extensions in a
chart, with the two variable positions represented on the two axes. For
example, the extension above could be expressed via a table like the one
below. The '0' in the first cell of the table says that is not in the
extension of $L$; the next cell in the first row says that is. Etc.
Sometimes drawing out a chart like this will be the easiest way to
represent models for the extensions of two-place predicates.

  $Lxy$    **1**   **2**   **3**   **4**   **5**   **6**   **7**   **8**   **9**   **10**
  -------- ------- ------- ------- ------- ------- ------- ------- ------- ------- --------
  **1**    0       1       1       1       1       1       1       1       1       1
  **2**    0       0       1       1       1       1       1       1       1       1
  **3**    0       0       0       1       1       1       1       1       1       1
  **4**    0       0       0       0       1       1       1       1       1       1
  **5**    0       0       0       0       0       1       1       1       1       1
  **6**    0       0       0       0       0       0       1       1       1       1
  **7**    0       0       0       0       0       0       0       1       1       1
  **8**    0       0       0       0       0       0       0       0       1       1
  **9**    0       0       0       0       0       0       0       0       0       1
  **10**   0       0       0       0       0       0       0       0       0       0

The extension of a three-place predicate is a set of ordered triples
where the predicate is true of those three things *in that order*. So
the extension of $T$ in this model will contain ordered triples like ,
because $2\times 4 = 8$. Because the surface of a sheet of paper is for
all intents and purposes two-dimensional, it is usually not convenient
to represent 3-or-more place predicates with tables.

Generally, the extension of an n-place predicate is a set of all ordered
n-tuples ${\langle}a_1, a_2,\ldots, a_n{\rangle}$ such that $a_1$--$a_n$
are members of the UD and the predicate is true of $a_1$--$a_n$ in that
order.

Working with models {#sec.UsingModels}
-------------------

We will use the double turnstile symbol for QL much as we did for SL.
'$\metaA{}\models\metaB{}$' means that ' entails ': When and are two
sentences of QL, $\metaA{}\models\metaB{}$ means that there is no model
in which is true and is false. $\models\metaA{}$ is shorthand for
$\emptyset\models\metaA{}$, which means that is true in every model.
This allows us to give definitions for various concepts in QL. In fact,
we can use the same definitions offered in Chapter
[\[ch.SLmodels\]](#ch.SLmodels){reference-type="ref"
reference="ch.SLmodels"}.

> A is a sentence that is true in every model; i.e., $\models\metaA{}$.
>
> A is a sentence that is false in every model; i.e.,
> $\models\enot\metaA{}$.
>
> A sentence is if and only if it is neither a tautology nor a
> contradiction.
>
> An argument " $\script{P}_1, \script{P}_2, \cdots$,   " is if and only
> if there is no model in which all of the premises are true and the
> conclusion is false; i.e.,
> $\{\script{P}_1,\script{P}_2,\cdots\}\models\metaC{}$. It is
> otherwise.
>
> Two sentences and are if and only if both $\metaA{}\models\metaB{}$
> and $\metaB{}\models\metaA{}$.
>
> The set $\{\metaA{}_1,\metaA{}_2,\metaA{}_3,\cdots\}$ is if and only
> if there is at least one model in which all of the sentences are true.
> The set is if and only if there is no such model.

Constructing models
-------------------

Suppose we want to show that $\forall xAxx \eif Bd$ is *not* a
tautology. This requires showing that the sentence is not true in every
model. If we can provide an example of a model in which the sentence is
false, then we will have shown that the sentence is not a tautology.

What would such a model look like? In order for $\forall xAxx \eif Bd$
to be false, the antecedent ($\forall x Axx$) must be true, and the
consequent ($Bd$) must be false.

To construct such a model, we start with a UD. It will be easier to
specify extensions for predicates if we have a small UD, so start with a
UD that has just one member. Formally, this single member might be
anything. Let's say it is Miles Morales.

We want $\forall x Axx$ to be true, so we want all members of the UD to
be paired with themself in the extension of $A$; this means that the
extension of $A$ must be {}.

We want $Bd$ to be false, so the referent of $d$ must not be in the
extension of $B$. We give $B$ an empty extension.

Since Miles is the only member of the UD, it must be the referent of
$d$. The model we have constructed looks like this:

UD & {Miles Morales}\
& {}\
& $\emptyset$\
& Miles Morales

Strictly speaking, a model specifies an extension for *every* predicate
of QL and a referent for *every* constant. As such, it is generally
impossible to write down a complete model. That would require writing
down infinitely many extensions and infinitely many referents. However,
we do not need to consider every predicate in order to show that there
are models in which $\forall xAxx \eif Bd$ is false. Predicates like $H$
and constants like $f_{13}$ make no difference to the truth or falsity
of this sentence. It is enough to specify extensions for $A$ and $B$ and
a referent for $d$, as we have done. This provides a *partial model* in
which the sentence is false.

Perhaps you are wondering: What does the predicate $A$ mean in English?
It doesn't really matter. For formal purposes, the existence of models
like the ones described above are enough to show that
$\forall x Axx \eif Bd$ is not a tautology. But we can offer an
interpretation in English if we like. How about this one?

Miles Morales

$x$ knows $y$'s biggest secret.

$x$'s powers derive from gamma radiation.

Miles Morales

This is one way we can interpret the model above. $Add$ is true, because
Miles does know Miles's biggest secret. (It's that he's the Ultimate
Spider-Man. Now you know it too!) $Bd$ is false: Miles's powers came
from a genetically enhanced spider bite, not from gamma radiation. But
the partial model constructed above includes none of these
interpretative details. All it says is that $A$ is a predicate which is
true of Miles and Miles, and that $B$ is a predicate which does not
apply to Miles. There are indefinitely many predicates in English that
have this extension. $Axy$ might instead translate '$x$ is the same size
as $y$' or '$x$ and $y$ live in the same city'; $Bx$ might translate
'$x$ is a billionaire' or '$x$'s uncle was killed by a robber' or
'Donald Trump has written a tweet about $x$'. In constructing a model
and giving extensions for $A$ and $B$, we do not specify what English
predicates $A$ and $B$ should be used to translate. We are concerned
with whether the $\forall xAxx \eif Bd$ comes out true or false, and all
that matters for truth and falsity in QL is the information in the
model: the UD, the extensions of predicates, and the referents of
constants.

We can just as easily show that $\forall xAxx \eif Bd$ is not a
contradiction. We need only specify a model in which
$\forall xAxx \eif Bd$ is true; i.e., a model in which either
$\forall x Axx$ is false or $Bd$ is true. Here is one such partial
model:

UD & {The Red Skull}\
& {}\
& {The Red Skull}\
& The Red Skull

I've switched our object from Miles Morales to The Red Skull to
emphasize that it doesn't matter what object you pick. (Changing the
examples all back to Miles would make no difference.) On this model,
$\forall xAxx \eif Bd$ is true, because it is a conditional with a true
consequent (as well as a true antecedent). We have now shown that
$\forall xAxx \eif Bd$ is neither a tautology nor a contradiction. By
the definition of 'contingent in QL,' this means that
$\forall xAxx \eif Bd$ is contingent. In general, showing that a
sentence is contingent will require two models: one in which the
sentence is true and another in which the sentence is false.

Suppose we want to show that $\forall x Sx$ and $\exists x Sx$ are not
logically equivalent. We need to construct a model in which the two
sentences have different truth values; we want one of them to be true
and the other to be false. We start by specifying a UD. Again, we make
the UD reasonably small so that we can specify extensions easily. But
this time we will need at least two members. If we only had one member
of the domain, we wouldn't be able to illustrate the difference between
*all* and *some*. Let's let our UD be {The Red Skull, Miles Morales}.

We can make $\exists x Sx$ true by including something in the extension
of $S$, and we can make $\forall x Sx$ false by leaving something out of
the extension of $S$. It does not matter which one we include and which
one we leave out. Making Miles the only $S$, we get a partial model that
looks like this:

UD & {Miles, The Red Skull}\
& {Miles}

This partial model shows that the two sentences are *not* logically
equivalent. $\exists x Sx$ is assigned 1 on this model, but
$\forall x Sx$ is assigned 0.

Back on p. , we said that this argument would be invalid in QL:

$(Rc \eand K_1c) \eand Tc$

$Tc \eand K_2c$

Now we can prove that this is so. To show that this argument is invalid,
we need to show that there is some model in which the premise is true
and the conclusion is false. We can construct such a model deliberately.
Here is one way to do it:

UD & {Reed Richards}\
& {Reed Richards}\
& {Reed Richards}\
& $\emptyset$\
& {Reed Richards}\
& Reed Richards

Similarly, we can show that a set of sentences is consistent by
constructing a model in which all of the sentences are true.

::: {#table.ModelOrArgument}
  ------------------------------ ----------------------------------------------------------------------- -----------------------------------------------------------------
                                 YES                                                                     NO
  Is a tautology?                show that must be true in any model                                     
  Is a contradiction?            show that must be false in any model                                    
  Is contingent?                                                                                         either show that is a tautology or show that is a contradiction
  Are and equivalent?            show that and must have the same truth value in any model               
  Is the set consistent?                                                                                 show that the sentences in could not all be true in any model
  Is the argument ',  ' valid?   show that any model in which is true must be a model in which is true   
                                                                                                         
  ------------------------------ ----------------------------------------------------------------------- -----------------------------------------------------------------

  : It is relatively easy to answer a question if you can do it by
  constructing a model or two. It is much harder if you need to reason
  about all possible models. This table shows when constructing models
  is enough.
:::

Reasoning about all models {#sec.allmodelreasoning}
--------------------------

We can show that a sentence is *not* a tautology just by providing one
carefully specified model: a model in which the sentence is false. To
show that something is a tautology, on the other hand, it would not be
enough to construct ten, one hundred, or even a thousand models in which
the sentence is true. It is only a tautology if it is true in *every*
model, and there are infinitely many models. This cannot be avoided just
by constructing partial models, because there are infinitely many
partial models.

Consider, for example, the sentence $Raa\eiff Raa$. There are two
logically distinct partial models of this sentence that have a 1-member
UD. There are 32 distinct partial models that have a 2-member UD. There
are 1526 distinct partial models that have a 3-member UD. There are
262,144 distinct partial models that have a 4-member UD. And so on to
infinity. In order to show that this sentence is a tautology, we need to
show something about all of these models. There is no hope of doing so
by dealing with them one at a time.

Nevertheless, $Raa\eiff Raa$ is obviously a tautology. We can prove it
with a simple argument:

> [\[allmodels1\]]{#allmodels1 label="allmodels1"} There are two kinds
> of models: those with $\langle$referent(a), referent(a)$\rangle$ is in
> the extension of $R$ and those in which it is not. In the first kind
> of model, $Raa$ is true; by the truth table for the biconditional,
> $Raa\eiff Raa$ is also true. In the second kind of model, $Raa$ is
> false; this makes $Raa\eiff Raa$ true. Since the sentence is true in
> both kinds of model, and since every model is one of the two kinds,
> $Raa\eiff Raa$ is true in every model. Therefore, it is a tautology.

This is a sound argument; it should convince us of its conclusion. But
note that it is not an argument in QL. Rather, it is an argument in
English *about* QL; it is an argument in the metalanguage. There is no
formal procedure for evaluating or constructing natural language
arguments like this one. The imprecision of natural language is the very
reason we began thinking about formal languages.

There are further difficulties with this approach.

Consider the sentence $\forall x(Rxx\eif Rxx)$, another obvious
tautology. It might be tempting to reason in this way: '$Rxx\eif Rxx$ is
true in every model, so $\forall x(Rxx\eif Rxx)$ must be true.' The
problem is that $Rxx\eif Rxx$ is *not* true in every model. It is not a
sentence, and so it is *neither* true *nor* false. We do not yet have
the vocabulary to say what we want to say about $Rxx\eif Rxx$. In the
next section, we introduce the concept of *satisfaction*; after doing
so, we will be better able to provide an argument that
$\forall x(Rxx\eif Rxx)$ is a tautology.

It is necessary to reason about an infinity of models to show that a
sentence is a tautology. Similarly, it is necessary to reason about an
infinity of models to show that a sentence is a contradiction, that two
sentences are equivalent, that a set of sentences is inconsistent, or
that an argument is valid. There are other things we can show by
carefully constructing a model or two. Table
[1.1](#table.ModelOrArgument){reference-type="ref"
reference="table.ModelOrArgument"} summarizes which things are which.

Truth in QL {#sec.TruthInQL}
-----------

For SL, we split the definition of truth into two parts: a truth value
assignment ($a$) for sentence letters and a truth function ($v$) for all
sentences. The truth function covered the way that complex sentences
could be built out of sentence letters and connectives.

In the same way that truth for SL is always *truth given a truth value
assignment*, truth for QL is *truth in a model*. The atomic sentences,
again, are $n$-place predicates followed by $n$ constants, like $Pj$. It
is true in a model if and only if the referent of $j$ is in the
extension of $P$ in .

We could go on in this way to define truth for all atomic sentences that
contain only predicates and constants: Consider any sentence of the form
$\script{R}\script{a}_1\ldots\script{a}_n$ where is an n-place predicate
and the s are constants. It is true in if and only if
${\langle}\referent{\script{a}_1},\ldots,\referent{\script{a}_n}{\rangle}$
is in in .

We could then define truth for sentences built up with sentential
connectives in the same way we did for SL. For example, the sentence
$(Pj \eif Mda)$ is true in if either $Pj$ is false in or $Mda$ is true
in .

Unfortunately, this approach will fail when we consider sentences
containing quantifiers. Consider $\forall x Px$. When is it true in a
model ? The answer cannot depend on whether $Px$ is true or false in ,
because the $x$ in $Px$ is a free variable. $Px$ is not a sentence. It
is neither true nor false.

We were able to give a recursive definition of truth for SL because
every well-formed formula of SL has a truth value. This is not true in
QL, so we cannot define truth by starting with the truth of atomic
sentences and building up. We also need to consider the atomic formulae
which are not sentences. In order to do this we will define
*satisfaction*; every well-formed formula of QL will be satisfied or not
satisfied, even if it does not have a truth value. We will then be able
to define *truth* for sentences of QL in terms of satisfaction.

Satisfaction
------------

The formula $Px$ says, roughly, that $x$ is one of the $P$s. This cannot
be quite right, however, because $x$ is a variable and not a constant.
It does not name any particular member of the UD. Instead, its meaning
in a sentence is determined by the quantifier that binds it. The
variable $x$ must stand-in for every member of the UD in the sentence
$\forall xPx$, but it only needs to stand-in for one member in
$\exists xPx$. Since we want the definition of satisfaction to cover
$Px$ without any quantifier whatsoever, we will start by saying how to
interpret a free variable like the $x$ in $Px$.

We do this by introducing a *variable assignment*. Formally, this is a
function that matches up each variable with a member of the UD. Call
this function 'a'. (The 'a' is for 'assignment', but this is not the
same as the truth value assignment that we used in defining truth for
SL.)

The formula $Px$ is satisfied in a model by a variable assignment $a$ if
and only if $a(x)$, the object that $a$ assigns to $x$, is in the
extension of P in .

When is $\forall x Px$ satisfied? It is not enough if $Px$ is satisfied
in by $a$, because that just means that $a(x)$ is in . $\forall x Px$
requires that every other member of the UD be in as well.

So we need another bit of technical notation: For any member $\pi$ of
the UD and any variable , let $a[\pi|\script{x}]$ be the variable
assignment that assigns $\pi$ to but agrees with $a$ in all other
respects. We have used $\pi$, the Greek letter *pi*, to underscore the
fact that it is some member of the UD and not some symbol of QL.
Suppose, for example, that the UD is presidents of the United States.
The function $a[\mbox{Grover Cleveland}|x]$ assigns Grover Cleveland to
the variable $x$, regardless of what $a$ assigns to $x$; for any other
variable, $a[\mbox{Grover Cleveland}|x]$ agrees with $a$.

We can now say concisely that $\forall x Px$ is satisfied in a model by
a variable assignment $a$ if and only if, for every object $\pi$ in the
UD of , $Px$ is satisfied in by $a[\pi|x]$.

The intuitive thought here is that wff satisfaction is relative to a
variable assignment. A variable assignment is a way of treating each
variable as if it were a name for some object or other; a wff is
satisfied by a in a given model iff, in that model, treating the
variables the way $a$ suggests would yield a true wff.

You may worry that our statement of satisfaction by a variable
assignment in a model is circular, because it gives the satisfaction
conditions for the sentence $\forall x Px$ using the phrase 'for every
object.' However, it is important to remember the difference between a
logical symbol like '$\forall$' and an English language word like
'every.' The word is part of the metalanguage that we use in defining
satisfaction conditions for object language sentences that contain the
symbol.

We can now give a general definition of satisfaction, extending from the
cases we have already discussed. We define a function $s$ (for
'satisfaction') in a model such that for any wff and variable assignment
$a$, $s(\metaA{}, a)=1$ if is satisfied in by $a$; otherwise
$s(\metaA{}, a)=0$.

1.  If is an atomic wff of the form
    $\script{P}\script{t}_1\ldots\script{t}_n$ and $\pi_i$ is the object
    picked out by $t_i$, then $$s(\metaA{}, a) =
        \left\{\begin{array}{ll}
        1 & \mbox{if ${\langle}\pi_1\ldots\pi_n{\rangle}$ is in \extension{\script{P}} in \model{M}},\\
        0 & \mbox{otherwise.}
        \end{array}\right.$$

    For each term $t_i$: If $t_i$ is a constant, then
    $\pi_i = \referent{t_i}$. If $t_i$ is a variable, then
    $\pi_i = a(t_i)$.

2.  If is ${\enot}\metaB{}$ for some wff , then $$s(\metaA{}, a) =
        \left\{\begin{array}{ll}
        1 & \mbox{if $s(\metaB{}, a) = 0$},\\
        0 & \mbox{otherwise.}
        \end{array}\right.$$

3.  If is $(\metaB{}\eand\metaC{})$ for some wffs , , then
    $$s(\metaA{}, a) =
        \left\{\begin{array}{ll}
        1 & \mbox{if $s(\metaB{}, a) = 1$ and $s(\metaC{}, a) = 1$,}\\
        0 & \mbox{otherwise.}
        \end{array}\right.$$

4.  If is $(\metaB{}\eor\metaC{})$ for some wffs , , then
    $$s(\metaA{}, a) =
        \left\{\begin{array}{ll}
        0 & \mbox{if $s(\metaB{}, a) = 0$  and $s(\metaC{}, a) = 0$,}\\
        1 & \mbox{otherwise.}
        \end{array}\right.$$

5.  If is $(\metaB{}\eif\metaC{})$ for some wffs , , then
    $$s(\metaA{}, a) =
        \left\{\begin{array}{ll}
        0 & \mbox{if $s(\metaB{}, a) = 1$ and $s(\metaC{}, a) = 0$,}\\
        1 & \mbox{otherwise.}
        \end{array}\right.$$

6.  If is $(\metaB{}\eiff\metaC{})$ for some wffs , , then
    $$s(\metaA{}, a) =
        \left\{\begin{array}{ll}
        1 & \mbox{if $s(\metaB{}, a) = s(\metaC{}, a)$},\\
        0 & \mbox{otherwise.}
        \end{array}\right.$$

7.  If is $\forall\script{x} \metaB{}$ for some wff and some variable ,
    then $$s(\metaA{}, a) =
        \left\{\begin{array}{ll}
        1 & \mbox{if $s(\metaB{}, a[\pi|\script{x}])=1$ for every member $\pi$ of the UD},\\
        0 & \mbox{otherwise.}
        \end{array}\right.$$

8.  If is $\exists\script{x} \metaB{}$ for some wff and some variable ,
    then $$s(\metaA{}, a) =
        \left\{\begin{array}{ll}
        1 & \mbox{if $s(\metaB{}, a[\pi|\script{x}])=1$ for at least one member $\pi$ of the UD},\\
        0 & \mbox{otherwise.}
        \end{array}\right.$$

This definition follows the same structure as the definition of a wff
for QL, so we know that every wff of QL will be covered by this
definition. For a model and a variable assignment $a$, any wff will
either be satisfied or not. No wffs are left out or assigned conflicting
values.

Truth in QL {#truth-in-ql}
-----------

Consider a simple sentence like $\forall xPx$. By part 7 in the
definition of satisfaction, this sentence is satisfied if $a[\pi|x]$
satisfies $Px$ in for every $\pi$ in the UD. In other words, assign that
$x$ to any object in the UD you like, and the resultant wff will come
out true. By part 1 of the definition, this will be the case if every
$\pi$ is in the extension of $P$. Whether $\forall xPx$ is satisfied
does not depend on the particular variable assignment $a$. If this
sentence is satisfied, then it is true. This is a formalization of what
we have said all along: $\forall xPx$ is true if everything in the UD is
in the extension of $P$.

The same thing holds for any sentence of QL. Because all of the
variables are bound, a sentence is satisfied or not regardless of the
details of the variable assignment. So we can define truth in this way:
A sentence is if and only if some variable assignment satisfies in $M$;
is otherwise.

Truth in QL is *truth in a model*. Sentences of QL are not flat-footedly
true or false as mere symbols, but only relative to a model. A model
provides the meaning of the symbols, insofar as it makes any difference
to truth and falsity.

Reasoning about all models (reprise)
------------------------------------

At the end of section [1.6](#sec.allmodelreasoning){reference-type="ref"
reference="sec.allmodelreasoning"}, we were stymied when we tried to
show that $\forall x(Rxx\eif Rxx)$ is a tautology. Having defined
satisfaction, we can now reason in this way:

> Consider some arbitrary model . Now consider an arbitrary member of
> the UD; for the sake of convenience, call it $\pi$. It must be the
> case either that $\langle\pi,\pi\rangle$ is in the extension of $R$ or
> that it is not. If $\langle\pi,\pi\rangle$ is in the extension of $R$,
> then $Rxx$ is satisfied by a variable assignment that assigns $\pi$ to
> $x$ (by part 1 of the definition of satisfaction); since the
> consequent of $Rxx\eif Rxx$ is satisfied, the conditional is satisfied
> (by part 5). If $\langle\pi,\pi\rangle$ is not in the extension of
> $R$, then $Rxx$ is not satisfied by a variable assignment that assigns
> $\pi$ to $x$ (by part 1); since antecedent of $Rxx\eif Rxx$ is not
> satisfied, the conditional is satisfied (by part 5). In either case,
> $Rxx\eif Rxx$ is satisfied. This is true for any member of the UD, so
> $\forall x(Rxx \eif Rxx)$ is satisfied by any truth value assignment
> (by part 7). So $\forall x(Rxx \eif Rxx)$ is true in (by the
> definition of truth). This argument holds regardless of the exact UD
> and regardless of the exact extension of $R$, so
> $\forall x(Rxx \eif Rxx)$ is true in any model. Therefore, it is a
> tautology.

Giving arguments about all possible models typically requires clever
combination of two strategies:

1\. Divide cases between two possible kinds, such that every case must
be one kind or the other. In the argument on p. , for example, we
distinguished two kinds of models based on whether or not a specific
ordered pair was in . In the argument above, we distinguished cases in
which an ordered pair was in and cases in which it was not.

2\. Consider an arbitrary object as a way of showing something more
general. In the argument above, it was crucial that $\pi$ was just some
arbitrary member of the UD. We did not assume anything special about it.
As such, whatever we could show to hold of $\pi$ must hold of every
member of the UD --- if we could show it for $\pi$, we could show it for
anything. In the same way, we did not assume anything special about ,
and so whatever we could show about must hold for all models.

Consider one more example. The argument $\forall x(Hx \eand Jx)$
$\forall x Hx$ is obviously valid. We can only show that the argument is
valid by considering what must be true in every model in which the
premise is true.

> Consider an arbitrary model in which the premise
> $\forall x(Hx \eand Jx)$ is true. The conjunction $Hx \eand Jx$ is
> satisfied regardless of what is assigned to $x$, so $Hx$ must be also
> (by part 3 of the definition of satisfaction). As such, $\forall x Hx$
> is satisfied by any variable assignment (by part 7 of the definition
> of satisfaction) and true in (by the definition of truth). Since we
> did not assume anything about besides $\forall x(Hx \eand Jx)$ being
> true, $\forall x Hx$ must be true in any model in which
> $\forall x(Hx \eand Jx)$ is true. So
> $\forall x(Hx \eand Jx) \models \forall x Hx$.

Even for a simple argument like this one, the reasoning is somewhat
complicated. For longer arguments, the reasoning can be insufferable.
The problem arises because talking about an infinity of models requires
reasoning things out in English. What are we to do? The answer won't
surprise readers of the first half of the book: we'll make use of some
formal proof systems. We have seen two kinds of proof systems for SL:
the tree method, and natural deduction proofs. In the coming chapters,
we'll extend both kinds of systems to QL as well.

[\[pr.TorF1\]]{#pr.TorF1 label="pr.TorF1"} Determine whether each
sentence is true or false in the model given.

UD & {Corwin, Benedict}\
& {Corwin, Benedict}\
& {Benedict}\
& $\emptyset$\
& Corwin

$Bc$

$Ac \eiff \enot Nc$

$Nc \eif (Ac \eor Bc)$

$\forall x Ax$

$\forall x \enot Bx$

$\exists x(Ax \eand Bx)$

$\exists x(Ax \eif Nx)$

$\forall x(Nx \eor \enot Nx)$

$\exists x Bx \eif \forall x Ax$

[\[pr.TorF2\]]{#pr.TorF2 label="pr.TorF2"} Determine whether each
sentence is true or false in the model given.

UD & {Waylan, Willy, Johnny}\
& {Waylan, Willy, Johnny}\
& {Waylan, Willy}\
& {,,}\
& Johnny

$\exists x(Rxm \eand Rmx)$

$\forall x(Rxm \eor Rmx)$

$\forall x(Hx \eiff Wx)$

$\forall x(Rxm \eif Wx)$

$\forall x\bigl[Wx \eif(Hx \eand Wx)\bigr]$

$\exists x Rxx$

$\exists x\exists y Rxy$

$\forall x \forall y Rxy$

$\forall x \forall y (Rxy \eor Ryx)$

$\forall x \forall y \forall z\bigl[(Rxy \eand Ryz) \eif Rxz\bigr]$

[\[pr.TorF3\]]{#pr.TorF3 label="pr.TorF3"} Determine whether each
sentence is true or false in the model given.

UD & {Lemmy, Courtney, Eddy}\
& {Lemmy, Courtney, Eddy}\
& {Courtney}\
& {Lemmy, Eddy}\
& Courtney\
& Eddy

$Hc$

$He$

$Mc \eor Me$

$Gc \eor \enot Gc$

$Mc \eif Gc$

$\exists x Hx$

$\forall x Hx$

$\exists x \enot Mx$

$\exists x(Hx \eand Gx)$

$\exists x(Mx \eand Gx)$

$\forall x(Hx \eor Mx)$

$\exists x Hx \eand \exists x Mx$

$\forall x(Hx \eiff \enot Mx)$

$\exists x Gx \eand \exists x \enot Gx$

$\forall x\exists y(Gx \eand Hy)$

[\[pr.InterpretationToModel\]]{#pr.InterpretationToModel
label="pr.InterpretationToModel"} Write out the model that corresponds
to the interpretation given.

UD: natural numbers from 10 to 13

Ox: $x$ is odd.

Sx: $x$ is less than 7.

Tx: $x$ is a two-digit number.

Ux: $x$ is thought to be unlucky.

Nxy: $x$ is the next number after $y$.

[\[pr.Contingent\]]{#pr.Contingent label="pr.Contingent"} Show that each
of the following is contingent.

 $Da \eand Db$

 $\exists x Txh$

 $Pm \eand \enot\forall x Px$

$\forall z Jz \eiff \exists y Jy$

$\forall x (Wxmn \eor \exists yLxy)$

$\exists x (Gx \eif \forall y My)$

[\[pr.NotEquiv\]]{#pr.NotEquiv label="pr.NotEquiv"} Show that the
following pairs of sentences are not logically equivalent.

$Ja$, $Ka$

$\exists x Jx$, $Jm$

$\forall x Rxx$, $\exists x Rxx$

$\exists x Px \eif Qc$, $\exists x (Px \eif Qc)$

$\forall x(Px \eif \enot Qx)$, $\exists x(Px \eand \enot Qx)$

$\exists x(Px \eand Qx)$, $\exists x(Px \eif Qx)$

$\forall x(Px\eif Qx)$, $\forall x(Px \eand Qx)$

$\forall x\exists y Rxy$, $\exists x\forall y Rxy$

$\forall x\exists y Rxy$, $\forall x\exists y Ryx$

Show that the following sets of sentences are consistent.

{Ma, Na, Pa, Qa}

{$Lee$, $Lef$, $\enot Lfe$, $\enot Lff$}

{$\enot (Ma \eand \exists x Ax)$, $Ma \eor Fa$, $\forall x(Fx \eif Ax)$}

{$Ma \eor Mb$, $Ma \eif \forall x \enot Mx$}

{$\forall y Gy$, $\forall x (Gx \eif Hx)$, $\exists y \enot Iy$}

{$\exists x(Bx \eor Ax)$, $\forall x \enot Cx$,
$\forall x\bigl[(Ax \eand Bx) \eif Cx\bigr]$}

{$\exists x Xx$, $\exists x Yx$, $\forall x(Xx \eiff \enot Yx)$}

{$\forall x(Px \eor Qx)$, $\exists x\enot(Qx \eand Px)$}

{$\exists z(Nz \eand Ozz)$, $\forall x\forall y(Oxy \eif Oyx)$}

{$\enot \exists x \forall y Rxy$, $\forall x \exists y Rxy$}

Construct models to show that the following arguments are invalid.

$\forall x(Ax \eif Bx)$,  $\exists x Bx$

$\forall x(Rx \eif Dx)$, $\forall x(Rx \eif Fx)$,
 $\exists x(Dx \eand Fx)$

$\exists x(Px\eif Qx)$, $\exists x Px$

$Na \eand Nb \eand Nc$,  $\forall x Nx$

$Rde$, $\exists x Rxd$,  $Red$

$\exists x(Ex \eand Fx)$, $\exists x Fx \eif \exists x Gx$,
 $\exists x(Ex \eand Gx)$

$\forall x Oxc$, $\forall x Ocx$,  $\forall x Oxx$

$\exists x(Jx \eand Kx)$, $\exists x \enot Kx$, $\exists x \enot Jx$,
 $\exists x(\enot Jx \eand \enot Kx)$

$Lab \eif \forall x Lxb$, $\exists x Lxb$,  $Lbb$

[\[pr.SemanticsEssay\]]{#pr.SemanticsEssay label="pr.SemanticsEssay"}

Many logic books define consistency and inconsistency in this way: " A
set $\{\metaA{}_1,\metaA{}_2,\metaA{}_3,\cdots\}$ is inconsistent if and
only if
$\{\metaA{}_1,\metaA{}_2,\metaA{}_3,\cdots\}\models(\metaB{}\eand\enot\metaB{})$
for some sentence . A set is consistent if it is not inconsistent."

Does this definition lead to any different sets being consistent than
the definition on p. ? Explain your answer.

 Our definition of truth says that a sentence is if and only if some
variable assignment satisfies in $M$. Would it make any difference if we
said instead that is if and only if *every* variable assignment
satisfies in $M$? Explain your answer.
